# NCL 2016 : EasySploit-80

__Category__: Exploitation

__Points__: 80

## Write-up

<a href="https://jhalon.github.io/images/nclp-7.png"><img src="https://jhalon.github.io/images/nclp-7.png"></a>

For this challenge we are provided the following file: [NCL-2016-Game2-EasySploit.c](https://jhalon.github.io/download/NCL-2016-Game2-EasySploit.c)

--

__What is the gcc flag used to disable stack protection?__

GCC is the [GNU Compiler Collection](https://gcc.gnu.org/) usually used for C and C++ - some understanding of those languages is needed here.

Google GCC Disable Stack PRotection > The answer is provided [here](http://stackoverflow.com/questions/2340259/how-to-turn-off-gcc-compiler-optimization-to-enable-buffer-overflow).

__Answer: fno-stack-protector__

--

__What type of security vulnerability exists in this program?__

Since this is a C file, all we really need to do is just open the file in a text editor to read the code.

```console
root@kali:~/Downloads# gedit NCL-2016-Game2-EasySploit.c 
```

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
  char buff[15];
  int pass = 0;

  printf("\n Enter the password : \n");
  gets(buff);

  if(strcmp(buff, "asecurepassword"))
  {
    printf ("\n Wrong Password \n");
  }
  else
  {
    printf ("\n Correct Password \n");
    pass = 1;
  }

  if(pass)
  {
    /* Now Give root or admin rights to user*/
    printf ("\n Root privileges given to the user \n");
  }

  return 0;
}
```

Looking at the code, we can see that it is written in C. Now two things really stand out here.

1) __char buff[15];__

2) __gets(buff);__

Let me explain to you what is occurring - for those who don't understand C language. The char (or character - used for strings) ‘buff’ represents an array of 15 bytes where buff[0] is the left boundary and buff[14] is the right boundary of the buffer.

A buffer, in terms of a program in execution, can be thought of as a region of computer’s main memory that has certain boundaries in context with the program variable that references this memory.

Since the C function [gets](https://www.tutorialspoint.com/c_standard_library/c_function_gets.htm) is being used, we instantly know that the program is insecure and a Buffer Overflow is present. This is due to the fact that __gets__ does not terminate the end of the strings buffer (or 15 chars).

A buffer is said to be overflown when the data (meant to be written into memory buffer) gets written past the left or the right boundary of the buffer. This way the data gets written to a portion of memory which does not belong to the program variable that references the buffer.

For this to be secure, we would need to use [fgets](https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm) , which terminates the end of the string buffer with a null byte '\0', that stops further execution beyond the 15 chars.

Overall, this is a [Buffer Overflow](https://en.wikipedia.org/wiki/Buffer_overflow) Vulnerability.


__Answer: Buffer Overflow__

--

__On what line number is a vulnerable function call made?__

Like I explained above, look for the line with the unsecure __gets__ command, which is on line 10.

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
  char buff[15];
  int pass = 0;

  printf("\n Enter the password : \n");
  gets(buff);

  if(strcmp(buff, "asecurepassword"))
  {
    printf ("\n Wrong Password \n");
  }
  else
  {
    printf ("\n Correct Password \n");
    pass = 1;
  }

  if(pass)
  {
    /* Now Give root or admin rights to user*/
    printf ("\n Root privileges given to the user \n");
  }

  return 0;
}
```

__Answer: 10__

--

__Without entering the "correct" password, what is the minimum number of input characters needed to bypass the password check?__

If you actually read my explanation in question 1, then you would know that since __gets__ is being used, and the buffer is not being terminated at 15 chars... we would have to use a minimum number of 16 chars to overrun the buffer's boundary and overwrite to adjacent memory locations.

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
  char buff[15];
  int pass = 0;

  printf("\n Enter the password : \n");
  gets(buff);

  if(strcmp(buff, "asecurepassword"))
  {
    printf ("\n Wrong Password \n");
  }
  else
  {
    printf ("\n Correct Password \n");
    pass = 1;
  }

  if(pass)
  {
    /* Now Give root or admin rights to user*/
    printf ("\n Root privileges given to the user \n");
  }

  return 0;
}
```

__Answer: 16__

## Other Write-ups and Resources

* [Jack Halon - KKB](https://jhalon.github.io/ncl-regular-season-2/)
