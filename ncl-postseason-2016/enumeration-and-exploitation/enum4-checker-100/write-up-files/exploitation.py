
# Writing out the code in python allows for quick testing
# in python REPL. Import this code and run loop1(), loop2(),
# and full() against different strings, just to see the outcomes.
# After testing different patterns we can create a solution.

# this one is fairly easy to find patterns due to xor operation
def loop1(number, debug=False):
	v2, v3 = 0, 0

	for digit in number:
		v3 = ord(digit) ^ v2

		if debug:
			print ord(digit), v2, v3
			
		v2 = v3

	return v3

# this one is a bit tougher to see patterns
# solve this by printing a bunch of info at each iteration
def loop2(number, debug=False):
	v4 = 0
	v5 = 0

	if debug:
		print("{:10}|{:10}|{:10}".format('digit','v4','v5'))

	for digit in number:
		v5 = ord(digit) + v4
		# two's complement:
		# v4 = (v5 % 256) | (v4 & 0x00)
		v4 = (v5 % 256) | (v4 & -256)

		if debug:
			print("{:10b}|{:10b}|{:10b}".format(ord(digit),v4,v5))

	return v5 % 256

# tries both loops and shows result (for brevity in checking answers)
def full(number):
	n1, n2 = loop1(number, False), loop2(number, False)
	print("loop1: {}".format(n1))
	print("loop2: {}".format(n2))

	return ((n1+n2) % 256)


# solved!
solution = '@'*12 + '6'*4


# For quick testing
import sys
if __name__ == '__main__':
	full(sys.argv[1])
