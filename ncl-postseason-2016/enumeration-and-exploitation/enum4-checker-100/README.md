# National Cyber League Postseason 2016 : Checker

**Category:** Enumeration and Exploitation  
**Points:** 100  
**Solves:**  
**Description:**  

> This program runs some form of check on a key input, can you find a valid key to unlock it?
> * 100: What is the value of a valid key?

## Write-up

We start this challenge with the Checker binaries. Attempting to run it gives an unhelpful prompt asking for a key, so instead we run it through an [online disassembler](https://retdec.com/). Looking through the resulting code (saved in [stuff.c](write-up-files/stuff.c)), we find the important part: a function `is_valid_key` which checks an input string and returns true or false.  
Looking through assembly code is always horrible, but an important thing to remember is to try to look at the big picture. Don't get bogged down with syntax that looks obscure, but move on and try to understand what the variables are doing.  
We can see that line 4 checks whether the input is 16 characters. Lines 10 and 20 are actually assembly shorthand for array indexing:

* `v3 = (int32_t)*(char *)(i + v1) ^ v2;` is `v3 = v1[i] ^ v2`
* `v5 = (int32_t)*(char *)(i + v1) + v4;` is `v5 = v1[i] + v4`

Recall that `^` is bitwise xor, and v1 is the input string. Also, it's important to see that the first loop only uses v2 and v3, while the second uses v4 and v5. After both loops are done, v3 and v5 are compared in a certain way, and the boolean result is returned.  

#### Break down each section
To make finding patterns easier, it helps to rewrite this code as a [python script](write-up-files/exploitation.py).

##### Find patterns in v3

```python
def loop1(inp):
	v2 = 0
	for d in inp:
		v3 = ord(d) ^ v2
		v2 = v3
	return v3

loop1('11')		# v3 = 0
loop1('12')		# v3 = 3
loop1('aa')		# v3 = 0
loop1('1111')	# v3 = 0
```

Remember that xor repeats! Xoring a value with itself yields 0; since `x ^ x = 0`, then `0 ^ x ^ x = 0`. Since our input string needs to be 16 characters, we could give it a string with any digit repeating an even number of times. This would result in `v3 = 0` (since `v2` is initialized to `0`), which allows us to focus on `v5` to manipulate the final checksum (line 26 of stuff.c).

##### Find patterns in v5
```python
def loop2(inp):
	v4 = 0
	for digit in inp:
		v5 = ord(digit) + v4
		# two's complement:
		# v4 = (v5 % 256) | (v4 & 0x00)
		v4 = (v5 % 256) | (v4 & -256)		# Bitmask: ensures that v4 < 256
	return v5 % 256
```

Some things to note:  
* The last line of the loop bitwise ors two numbers that are both less thant 256, so v4 remains as a one-byte integer (while v5 may increase past the value of `0xFF`).  
* Considering we found a pattern for v3 (we can force it to be `0`) we want `v5` to take on a value of `216 % 256` after the loop ends.  
* Take some time to see how the value of `v5` changes with different input:
```python
ord('1')		# 49
loop2('1111')	# 196 = 49*4
ord('a')		# 97
loop2('aaaa')	# 132 = 97*4 % 256
```

##### Solve final checksum
Taking a look forward to the final comparison:  
`result = (v5 + v3) % 256 == 216;`  
keep in mind we essentially want `v5 + v3` to equal `256`.  

Returning to our pattern for `v5`, and looking at the final check, we realize a simple conclusion: we want the ASCII values of our input digits to divide 256 or 216, so we can easily loop the values of v4 and v5:  
```python
chr(256/4)		# '@'
chr(216/4)		# '6'
loop2('@@@@')	# 0
loop2('6666')	# 216
```

Ha! Now we have a string `@@@@` that yields `v5 = 0` and `v3 = 0` (recall that two of the same digits xor'd give `0`). We also have a string `6666` that yields `v5 = 216` and `v3 = 0`. If we ever get `v5 = 0`, it won't affect the values of the next iterations of the loop (since it was initialized at `0`). So we can simply chain these strings together:  
```python
solution = '@@@@'*3 + '6666'
len(solution)					# 16 characters
loop1(solution)					# 0
loop2(solution)					# 216
```

So we have `v5 + v3 = 216 + 0 = 216`, which is exactly what we wanted. All that remains is to check this solution against the competition binary:  
```
$ ./NCL-2016-Post-Checker-64bit @@@@@@@@@@@@6666
Valid Key!!! Woot!
```

## Other write-ups and resources

(TODO)
